var documenterSearchIndex = {"docs":
[{"location":"#TimeInterpolatedGeoData.jl","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.jl","text":"","category":"section"},{"location":"","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.jl","text":"Modules = [TimeInterpolatedGeoData]","category":"page"},{"location":"#TimeInterpolatedGeoData.CachedStack","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.CachedStack","text":"CachedStack(stack; loaded=Dict{Symbol,Any}())\n\nA stack that wraps another Stack and stores any layers loaded  from it in a Dict. This prevents loading them multiple times from disk.\n\nIt also means the are locked from the garbage collector if they are  still in the Dict, which can cause problems with memory use.  Use  clear!(stack) to return to the unloaded state, freeing memory.\n\n\n\n\n\n","category":"type"},{"location":"#TimeInterpolatedGeoData.Cosine","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.Cosine","text":"Cosine()\n\nSimilar to a Linear interpolator, but using sin to calculate the weights, as if it is cyclic between two values.\n\n\n\n\n\n","category":"type"},{"location":"#TimeInterpolatedGeoData.HypTan","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.HypTan","text":"HypTan{S}()\n\nSimilar to a Linear interpolator, but using hyperbolic tangent to  calculate the weights. It has a multiplier X that controls how long the curve is near each index. This is automatically scaled so the max and min  values are always 0 and 1 for all X. At the limits, HypTan is essentially  Linear and NoInterp.\n\nHypTan{0} will error, instead uses Linear - which is identical.\n\n\n\n\n\n","category":"type"},{"location":"#TimeInterpolatedGeoData.InterpArray","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.InterpArray","text":"InterpArray(arrays::Tuple, fraction::Tuple)\n\nInterplatedArray holds multiple arrays the will be interpolated when indexed. The fractions to include from each arrays are captured in the fractions argument. You may use as many arrays as required.\n\n\n\n\n\n","category":"type"},{"location":"#TimeInterpolatedGeoData.MinMaxInterpolator","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.MinMaxInterpolator","text":"MinMaxIterpolator(times, interptype)\n\nSpecifies the time that correspond to the daily minimum and maximum.\n\nArguments\n\ntimes: a length 2 NamedTuple where the keys correspond to the layer names for the   minumum and maximum values, and the values specify the offset in hours at which they occur.\ninterptype: An Interpolations.jl InterpType. This package provides Cosine   and HypTan.\n\n\n\n\n\n","category":"type"},{"location":"#TimeInterpolatedGeoData.interpseries-Tuple{GeoData.GeoSeries, Any}","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.interpseries","text":"interpseries(series::GeoSeries, dates; interptypes, step=step(dates))\n\nGenerate a an interpolated GeoSeries from series for each date/time in dates.\n\ndates must define step if step kw is not passed in.  An AbstractRange or a DimensionalData.jl Dimension can also be used.\n\nArguments\n\nseries: a GeoSeries of GeoStack, with a Regular Sampled Ti dimension.\ndates: AbstractVector of dates\ninterptypes: a NamedTuple connecting a stack layer name with an Interpolations.jl InterpType.\n\n\n\n\n\n","category":"method"},{"location":"#TimeInterpolatedGeoData.interpstack-Tuple{Any, Any, Any}","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.interpstack","text":"interpstack(stacks, interptypes, frac)\n\nArguments\n\nstack: a Tuple of AbstractGeoStack, usually of length 2.\ninterptypes: a NamedTuple connecting stack layer name with an Interpolations.jl InterpType.   These are used for other layers used with the min/max layers.\nfrac: The fractional value, between 0 and 1, to interpolate to if the first stack   is at 0 and the second stack is at 1.\n\nExample\n\nistack = interpstack((stack1, stack2), (a=BSpline(Linear()), b=BSpline(Cosine())), 0.25)\n\n\n\n\n\n","category":"method"},{"location":"#TimeInterpolatedGeoData.meanday_minmaxseries-Tuple{GeoData.GeoSeries, Any}","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.meanday_minmaxseries","text":"meanday_minmaxseries(series::GeoSeries, dates, interptypes, mm_interpolators::NamedTuple) => GeoSeries\n\nGenerate a GeoSeries of MinMixStack for one day in each period in series, with slices for every step in the day.\n\nArguments\n\nseries: a GeoSeries of GeoStack\ndates: AbstractVector of dates\nstep: the step size of the intervals in the resulting GeoSeries.\ninterptypes: a NamedTuple connecting stack layer name with an Interpolations.jl InterpType.   These are used for other layers used with the min/max layers.\nmm_interpolators: a NamedTuple connecting new layer names (e.g. :temp) to a MinMaxFrac using other stack layers.\n\n\n\n\n\n","category":"method"},{"location":"#TimeInterpolatedGeoData.minmaxseries-Tuple{GeoData.GeoSeries, Any}","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.minmaxseries","text":"minmaxseries(series::GeoSeries, dates; interptypes, mm_interpolators::NamedTuple)\n\nGenerate a GeoSeries of MinMaxStack from series for each date/time in dates. Min/max interpolators are defined in the mm_interpolators, a NamedTuple of\n\ndates must define step if step kw is not passed in.  An AbstractRange or a DimensionalData.jl Dimension can also be used.\n\nArguments\n\nseries: a GeoSeries of GeoStack, with a Regular Sampled Ti dimension.\ndates: AbstractVector of dates\ninterptypes: a NamedTuple connecting stack layer name with an Interpolations.jl InterpType.   These are used for other layers used with the min/max layers.\nmm_interpolators: a NamedTuple connecting new layer names (e.g. :temp) to a MinMaxFrac using other stack layers.\n\n\n\n\n\n","category":"method"},{"location":"#TimeInterpolatedGeoData.minmaxstack-Tuple{Any, Any, Float64, NamedTuple, Any}","page":"TimeInterpolatedGeoData.jl","title":"TimeInterpolatedGeoData.minmaxstack","text":"minmaxstack(stacks, interptypes, tfrac, mm_fracs)\nminmaxstack(stacks, interptypes, tfrac, mm_interpolators, timestep)\n\nAn AbstractGeoStack that Provides interpolation for a value (often temperature) that usually has minimum and maximum values provided in separate layers. Other layers in the stack are interpolated, or not, as for interpstack.\n\nArguments\n\nstack: a Tuple of AbstractGeoStack, usually of length 3.\ninterptypes: a NamedTuple connecting stack layer name with an Interpolations.jl InterpType.   These are used for other layers used with the min/max layers.\ntfrac: the fraction of the outer timestep this slice is taken at\nmm_fracs: a NamedTuple connecting new layer names (e.g. :temp) to a MinMaxFrac using other stack layers.\nmm_interpolators: a NamedTuple connecting new layer names (e.g. :temp) to a MinMaxFrac using other stack layers.\ntimestep: the size of the inner timestep, e.g Hour(1)\n\n\n\n\n\n","category":"method"}]
}
